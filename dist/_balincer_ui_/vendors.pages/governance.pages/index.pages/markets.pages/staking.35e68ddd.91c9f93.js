(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{1323:function(e,t,r){"use strict";r.d(t,"a",(function(){return N})),r.d(t,"b",(function(){return y}));var n=r(674),o=r(675),c=r(630),d=r(623),m=r(620),l=r(140);const h={convertHexToNumber:e=>new c.c.BigNumber(e).toNumber(),convertHexToNumberOrNull(e){if(null===e)return null;return h.convertHexToNumber(e)},convertAmountToBigNumber(e){const t=e||0;if(c.c.BigNumber.isBigNumber(t))return t;if(l.isString(t)&&(0===t.indexOf("0x")||0===t.indexOf("-0x")))return new c.c.BigNumber(t.replace("0x",""),16);return new c.c.BigNumber(t.toString(10),10)},encodeAmountAsHexString(e){const t=h.convertAmountToBigNumber(e),r=t.toString(16);return t.isLessThan(0)?`-0x${r.substr(1)}`:`0x${r}`},numberToHex(e){if(!isFinite(e)&&!h.isHexStrict(e))throw new Error(`Given input ${e} is not a number.`);const t=new c.c.BigNumber(e),r=t.toString(16);return t.lt(0)?`-0x${r.substr(1)}`:`0x${r}`},isHexStrict:e=>(l.isString(e)||l.isNumber(e))&&/^(-)?0x[0-9a-f]*$/i.test(l.isNumber(e)?e.toString():e)},y={unmarshalIntoBlockWithoutTransactionData:e=>({...e,gasLimit:h.convertHexToNumber(e.gasLimit),gasUsed:h.convertHexToNumber(e.gasUsed),size:h.convertHexToNumber(e.size),timestamp:h.convertHexToNumber(e.timestamp),number:null===e.number?null:h.convertHexToNumber(e.number),difficulty:h.convertAmountToBigNumber(e.difficulty),totalDifficulty:h.convertAmountToBigNumber(e.totalDifficulty)}),unmarshalIntoBlockWithTransactionData(e){const t={...e,gasLimit:h.convertHexToNumber(e.gasLimit),gasUsed:h.convertHexToNumber(e.gasUsed),size:h.convertHexToNumber(e.size),timestamp:h.convertHexToNumber(e.timestamp),number:null===e.number?null:h.convertHexToNumber(e.number),difficulty:h.convertAmountToBigNumber(e.difficulty),totalDifficulty:h.convertAmountToBigNumber(e.totalDifficulty),transactions:[]};return t.transactions=l.map(e.transactions,(e=>y.unmarshalTransaction(e))),t},unmarshalTransaction:e=>({...e,blockNumber:null!==e.blockNumber?h.convertHexToNumber(e.blockNumber):null,transactionIndex:null!==e.transactionIndex?h.convertHexToNumber(e.transactionIndex):null,nonce:h.convertHexToNumber(e.nonce),gas:h.convertHexToNumber(e.gas),gasPrice:h.convertAmountToBigNumber(e.gasPrice),value:h.convertAmountToBigNumber(e.value)}),unmarshalTransactionReceipt:e=>({...e,blockNumber:h.convertHexToNumber(e.blockNumber),transactionIndex:h.convertHexToNumber(e.transactionIndex),cumulativeGasUsed:h.convertHexToNumber(e.cumulativeGasUsed),gasUsed:h.convertHexToNumber(e.gasUsed),logs:l.map(e.logs,y.unmarshalLog.bind(y))}),unmarshalTxData(e){if(void 0===e.from)throw new Error("txData must include valid 'from' value.");return{to:e.to,from:e.from,data:e.data,value:void 0!==e.value?h.convertAmountToBigNumber(e.value):void 0,gas:void 0!==e.gas?h.convertHexToNumber(e.gas):void 0,gasPrice:void 0!==e.gasPrice?h.convertAmountToBigNumber(e.gasPrice):void 0,nonce:void 0!==e.nonce?h.convertHexToNumber(e.nonce):void 0}},marshalTxData(e){if(void 0===e.from)throw new Error("txData must include valid 'from' value.");const t={...e};delete t.from;const r={...y._marshalCallTxDataBase(t),from:y.marshalAddress(e.from)},n=["gasPrice","gas","value","nonce"];return l.each(r,((e,t)=>{void 0===e&&l.includes(n,t)&&delete r[t]})),r},marshalCallData(e){const t={...e};delete t.from,delete t.overrides;return{...y._marshalCallTxDataBase(t),from:void 0===e.from?void 0:y.marshalAddress(e.from)}},marshalCallOverrides(e){const t={};for(const address in e)if(address){const r=e[address],n=y.marshalAddress(address),o=t[n]={};void 0!==r.code&&(o.code=r.code),void 0!==r.nonce&&(o.nonce=h.encodeAmountAsHexString(r.nonce)),void 0!==r.balance&&(o.balance=h.encodeAmountAsHexString(r.balance)),0===Object.keys(o).length&&delete t[n]}return t},marshalAddress(address){if(c.d.isAddress(address))return ethUtil.addHexPrefix(address);throw new Error(`Invalid address encountered: ${address}`)},marshalBlockParam(e){if(void 0===e)return m.b.Latest;return l.isNumber(e)?h.numberToHex(e):e},unmarshalLog:e=>({...e,logIndex:h.convertHexToNumberOrNull(e.logIndex),blockNumber:h.convertHexToNumberOrNull(e.blockNumber),transactionIndex:h.convertHexToNumberOrNull(e.transactionIndex)}),_marshalCallTxDataBase(e){let t;e.accessList&&Object.keys(e.accessList).length&&(t=Object.entries(e.accessList).map((([address,e])=>({address:address,storageKeys:e}))));return{data:e.data,to:void 0===e.to?void 0:y.marshalAddress(e.to),gasPrice:void 0===e.gasPrice?void 0:h.encodeAmountAsHexString(e.gasPrice),gas:void 0===e.gas?void 0:h.encodeAmountAsHexString(e.gas),value:void 0===e.value?void 0:h.encodeAmountAsHexString(e.value),nonce:void 0===e.nonce?void 0:h.encodeAmountAsHexString(e.nonce),...t?{type:1,accessList:t}:{}}}};var A,v;!function(e){e.TransactionMiningTimeout="TRANSACTION_MINING_TIMEOUT"}(A||(A={})),function(e){e.Geth="GETH",e.Ganache="GANACHE"}(v||(v={}));const w="Geth",T="EthereumJS TestRPC";class N{constructor(e,t={}){this.isZeroExWeb3Wrapper=!0,this.abiDecoder=new c.a([]),this._supportedProvider=e,this._provider=c.h.standardizeOrThrow(e),this._callAndTxnDefaults=t,this._jsonRpcRequestId=1}static isAddress(address){return c.d.isAddress(address)}static toUnitAmount(e,t){n.a.isValidBaseUnitAmount("amount",e),n.a.isNumber("decimals",t);const r=new d.a.BigNumber(10).pow(t);return e.div(r)}static toBaseUnitAmount(e,t){n.a.isNumber("decimals",t);const r=new d.a.BigNumber(10).pow(t).times(e);if(0!==r.decimalPlaces())throw new Error(`Invalid unit amount: ${e.toString(10)} - Too many decimal places`);return r}static toWei(e){n.a.isBigNumber("ethAmount",e);return N.toBaseUnitAmount(e,18)}static _assertBlockParam(e){l.isNumber(e)||l.isString(e)&&n.a.doesBelongToStringEnum("blockParam",e,m.b)}static _assertBlockParamOrString(e){try{N._assertBlockParam(e)}catch(t){try{return void n.a.isHexString("blockParam",e)}catch(t){throw new Error(`Expected blockParam to be of type "string | BlockParam", encountered ${e}`)}}}static _normalizeTxReceiptStatus(e){return l.isString(e)?h.convertHexToNumber(e):void 0===e?null:e}getContractDefaults(){return this._callAndTxnDefaults}getProvider(){return this._supportedProvider}setProvider(e){const t=c.h.standardizeOrThrow(e);this._provider=t}async isSenderAddressAvailableAsync(e){n.a.isETHAddressHex("senderAddress",e);const t=await this.getAvailableAddressesAsync(),r=e.toLowerCase();return l.includes(t,r)}async getNodeVersionAsync(){return await this.sendRawPayloadAsync({method:"web3_clientVersion"})}async getNetworkIdAsync(){const e=await this.sendRawPayloadAsync({method:"net_version"});return l.parseInt(e)}async getChainIdAsync(){const e=await this.sendRawPayloadAsync({method:"eth_chainId"});return l.parseInt(e)}async getTransactionReceiptIfExistsAsync(e){n.a.isHexString("txHash",e);const t=await this.sendRawPayloadAsync({method:"eth_getTransactionReceipt",params:[e]});if(null!==t&&null!==t.blockNumber){t.status=N._normalizeTxReceiptStatus(t.status);return y.unmarshalTransactionReceipt(t)}}async getTransactionByHashAsync(e){n.a.isHexString("txHash",e);const t=await this.sendRawPayloadAsync({method:"eth_getTransactionByHash",params:[e]});return y.unmarshalTransaction(t)}async getBalanceInWeiAsync(e,t){n.a.isETHAddressHex("owner",e),void 0!==t&&N._assertBlockParam(t);const r=y.marshalBlockParam(t),o=y.marshalAddress(e),c=await this.sendRawPayloadAsync({method:"eth_getBalance",params:[o,r]});return new d.a.BigNumber(c)}async doesContractExistAtAddressAsync(address){n.a.isETHAddressHex("address",address);const code=await this.getContractCodeAsync(address);return!/^0x0{0,40}$/i.test(code)}async getContractCodeAsync(address,e){n.a.isETHAddressHex("address",address),void 0!==e&&N._assertBlockParam(e);const t=y.marshalBlockParam(e),r=y.marshalAddress(address);return await this.sendRawPayloadAsync({method:"eth_getCode",params:[r,t]})}async getTransactionTraceAsync(e,t){n.a.isHexString("txHash",e);return await this.sendRawPayloadAsync({method:"debug_traceTransaction",params:[e,t]})}async signMessageAsync(address,e){n.a.isETHAddressHex("address",address),n.a.isString("message",e);return await this.sendRawPayloadAsync({method:"eth_sign",params:[address,e]})}async signTypedDataAsync(address,e){n.a.isETHAddressHex("address",address),n.a.doesConformToSchema("typedData",e,o.a.eip712TypedDataSchema);const t=["eth_signTypedData_v4","eth_signTypedData_v3","eth_signTypedData"];let r;for(const n of t)try{return await this.sendRawPayloadAsync({method:n,params:[address,"eth_signTypedData"===n?e:JSON.stringify(e)]})}catch(e){if(r=e,!/(not handled|does not exist|not supported)/.test(e.message))throw e}throw r}async getBlockNumberAsync(){const e=await this.sendRawPayloadAsync({method:"eth_blockNumber",params:[]});return h.convertHexToNumberOrNull(e)}async getAccountNonceAsync(address,e){n.a.isETHAddressHex("address",address),void 0!==e&&N._assertBlockParam(e);const t=y.marshalBlockParam(e),r=y.marshalAddress(address),o=await this.sendRawPayloadAsync({method:"eth_getTransactionCount",params:[r,t]});return n.a.isHexString("nonce",o),parseInt(o.substr(2),16)}async getBlockIfExistsAsync(e){N._assertBlockParamOrString(e);const t=y.marshalBlockParam(e),r=h.isHexStrict(e)?"eth_getBlockByHash":"eth_getBlockByNumber",n=await this.sendRawPayloadAsync({method:r,params:[t,!1]});let o;return null!==n&&(o=y.unmarshalIntoBlockWithoutTransactionData(n)),o}async getBlockWithTransactionDataAsync(e){N._assertBlockParamOrString(e);let t=e;l.isNumber(e)&&(t=h.numberToHex(e));const r=h.isHexStrict(e)?"eth_getBlockByHash":"eth_getBlockByNumber",n=await this.sendRawPayloadAsync({method:r,params:[t,!0]});return y.unmarshalIntoBlockWithTransactionData(n)}async getBlockTimestampAsync(e){N._assertBlockParamOrString(e);const t=await this.getBlockIfExistsAsync(e);if(void 0===t)throw new Error(`Failed to fetch block with blockParam: ${JSON.stringify(e)}`);return t.timestamp}async getAvailableAddressesAsync(){const e=await this.sendRawPayloadAsync({method:"eth_accounts",params:[]});return l.map(e,(address=>address.toLowerCase()))}async takeSnapshotAsync(){return Number(await this.sendRawPayloadAsync({method:"evm_snapshot",params:[]}))}async revertSnapshotAsync(e){n.a.isNumber("snapshotId",e);return await this.sendRawPayloadAsync({method:"evm_revert",params:[e]})}async mineBlockAsync(){await this.sendRawPayloadAsync({method:"evm_mine",params:[]})}async increaseTimeAsync(e){n.a.isNumber("timeDelta",e);const t=await this.getNodeVersionAsync();if(l.includes(t,w))return this.sendRawPayloadAsync({method:"debug_increaseTime",params:[e]});if(l.includes(t,T))return this.sendRawPayloadAsync({method:"evm_increaseTime",params:[e]});throw new Error(`Unknown client version: ${t}`)}async getLogsAsync(filter){if(void 0!==filter.blockHash&&(void 0!==filter.fromBlock||void 0!==filter.toBlock))throw new Error("Cannot specify 'blockHash' as well as 'fromBlock'/'toBlock' in the filter supplied to 'getLogsAsync'");let e=filter.fromBlock;l.isNumber(e)&&(e=h.numberToHex(e));let t=filter.toBlock;l.isNumber(t)&&(t=h.numberToHex(t));const r={method:"eth_getLogs",params:[{...filter,fromBlock:e,toBlock:t}]},n=await this.sendRawPayloadAsync(r);return l.map(n,y.unmarshalLog.bind(y))}async estimateGasAsync(e){n.a.doesConformToSchema("txData",e,o.a.txDataSchema);const t=y.marshalTxData(e),r=await this.sendRawPayloadAsync({method:"eth_estimateGas",params:[t]});return h.convertHexToNumber(r)}async createAccessListAsync(e,t){n.a.doesConformToSchema("callData",e,o.a.callDataSchema,[o.a.addressSchema,o.a.numberSchema,o.a.jsNumber]);const r=await this.sendRawPayloadAsync({method:"eth_createAccessList",params:[y.marshalCallData(e),y.marshalBlockParam(t)]});if(r.error)throw new Error(r.error);return{accessList:r.accessList.reduce(((e,t)=>(e[t.address]=e[t.address]||[],e[t.address].push(...t.storageKeys||[]),e)),{}),gasUsed:parseInt(r.gasUsed.slice(2),16)}}async callAsync(e,t){n.a.doesConformToSchema("callData",e,o.a.callDataSchema),void 0!==t&&N._assertBlockParam(t);const r=y.marshalBlockParam(t),c=y.marshalCallData(e),d=y.marshalCallOverrides(e.overrides||{});return await this.sendRawPayloadAsync({method:"eth_call",params:[c,r,...0===Object.keys(d).length?[]:[d]]})}async sendTransactionAsync(e){n.a.doesConformToSchema("txData",e,o.a.txDataSchema);const t=y.marshalTxData(e);return await this.sendRawPayloadAsync({method:"eth_sendTransaction",params:[t]})}async awaitTransactionMinedAsync(e,t=1e3,r){n.a.isHexString("txHash",e),n.a.isNumber("pollingIntervalMs",t),void 0!==r&&n.a.isNumber("timeoutMs",r);let o=await this.getTransactionReceiptIfExistsAsync(e);if(void 0!==o){const e=l.map(o.logs,this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));return{...o,logs:e}}let d=!1;r&&setTimeout((()=>d=!0),r);const m=new Promise(((r,n)=>{const m=c.e.setAsyncExcludingInterval((async()=>{if(d)return c.e.clearAsyncExcludingInterval(m),n(A.TransactionMiningTimeout);if(o=await this.getTransactionReceiptIfExistsAsync(e),void 0!==o){c.e.clearAsyncExcludingInterval(m);const e=l.map(o.logs,this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder)),t={...o,logs:e};r(t)}}),t,(e=>{c.e.clearAsyncExcludingInterval(m),n(e)}))}));return await m}async awaitTransactionSuccessAsync(e,t=1e3,r){const n=await this.awaitTransactionMinedAsync(e,t,r);if(1!==n.status)throw new Error(`Transaction failed: ${e}`);return n}async setHeadAsync(e){n.a.isNumber("blockNumber",e),await this.sendRawPayloadAsync({method:"debug_setHead",params:[h.numberToHex(e)]})}async sendRawPayloadAsync(e){if(!e.method)throw new Error(`Must supply method in JSONRPCRequestPayload, tried: [${e}]`);const t={id:this._jsonRpcRequestId++,params:[],jsonrpc:"2.0",...e},r=Object(c.g)(this._provider.sendAsync.bind(this._provider)),n=await r(t);if(!n)throw new Error("No response");const o=n.error?n.error.message||n.error:void 0;if(o)throw new Error(o);if(void 0===n.result)throw new Error("JSON RPC response has no result");return n.result}async getNodeTypeAsync(){const e=await this.getNodeVersionAsync();if(l.includes(e,w))return v.Geth;if(l.includes(e,T))return v.Ganache;throw new Error(`Unknown client version: ${e}`)}}},674:function(e,t,r){"use strict";r.d(t,"a",(function(){return A}));var n=r(891),o=r(630),c=r(140),d=r(1090),m=r(283),l=r.n(m);const h=/^0x[0-9A-F]*$/i,y=new n.a,A={isBigNumber(e,t){const r=o.c.BigNumber.isBigNumber(t);A.assert(r,A.typeAssertionMessage(e,"BigNumber",t))},isNumberLike(e,t){const r=o.c.BigNumber.isBigNumber(t),n="number"==typeof t;A.assert(r||n,A.typeAssertionMessage(e,"BigNumber | number",t))},isValidBaseUnitAmount(e,t){A.isBigNumber(e,t);const r=t.isLessThan(0);A.assert(!r,`${e} cannot be a negative number, found value: ${t.toNumber()}`);const n=0!==t.decimalPlaces();A.assert(!n,`${e} should be in baseUnits (no decimals), found value: ${t.toNumber()}`)},isString(e,t){A.assert(c.isString(t),A.typeAssertionMessage(e,"string",t))},isFunction(e,t){A.assert(c.isFunction(t),A.typeAssertionMessage(e,"function",t))},isHexString(e,t){A.assert(c.isString(t)&&h.test(t),A.typeAssertionMessage(e,"HexString",t))},isETHAddressHex(e,t){A.assert(c.isString(t),A.typeAssertionMessage(e,"string",t)),A.assert(o.d.isAddress(t),A.typeAssertionMessage(e,"ETHAddressHex",t))},doesBelongToStringEnum(e,t,r){const n=c.values(r),o=c.includes(n,t),d=c.map(n,(e=>`'${e}'`)).join(", ");A.assert(o,`Expected ${e} to be one of: ${d}, encountered: ${t}`)},hasAtMostOneUniqueValue(e,t){A.assert(c.uniq(e).length<=1,t)},isNumber(e,t){A.assert(c.isFinite(t),A.typeAssertionMessage(e,"number",t))},isNumberOrBigNumber(e,t){if(!c.isFinite(t)){let r=!1;"object"==typeof t&&(o.c.BigNumber.isBigNumber(t)&&(r=!0),Object(t).hasOwnProperty("_isBigNumber")&&!0===t._isBigNumber&&(r=!0),Object(t).hasOwnProperty("words")&&(r=!0),Object(t).hasOwnProperty("s")&&Object(t).hasOwnProperty("e")&&Object(t).hasOwnProperty("c")&&(r=!0),t instanceof o.c.BigNumber&&(r=!0),t instanceof l.a&&(r=!0)),A.assert(r,A.typeAssertionMessage(e,"number or BigNumber or BN",t))}},isBoolean(e,t){A.assert(c.isBoolean(t),A.typeAssertionMessage(e,"boolean",t))},isWeb3Provider(e,t){o.f.warn("DEPRECATED: Please use providerUtils.standardizeOrThrow() instead");const r=c.isFunction(t.send)||c.isFunction(t.sendAsync);A.assert(r,A.typeAssertionMessage(e,"Provider",t))},doesConformToSchema(e,t,r,n){if(void 0===t)throw new Error(`${e} can't be undefined`);void 0!==n&&y.addSchema(n);const o=y.validate(t,r),c=o.errors&&o.errors.length>0,d=c?`Expected ${e} to conform to schema ${r.id}\nEncountered: ${JSON.stringify(t,null,"\t")}\nValidation errors: ${o.errors.join(", ")}`:"";A.assert(!c,d)},doesMatchRegex(e,t,r){A.assert(r.test(t),A.typeAssertionMessage(e,String(r),t))},isWebUri(e,t){const r=void 0!==d.isWebUri(t);A.assert(r,A.typeAssertionMessage(e,"web uri",t))},isUri(e,t){const r=void 0!==d.isUri(t);A.assert(r,A.typeAssertionMessage(e,"uri",t))},isBlockParam(e,t){if(!(Number.isInteger(t)&&t>=0)&&"earliest"!==t&&"latest"!==t&&"pending"!==t)throw new Error(A.typeAssertionMessage(e,"BlockParam",t))},isArray(e,t){if(!Array.isArray(t))throw new Error(A.typeAssertionMessage(e,"Array",t))},assert(e,t){if(!e)throw new Error(t)},typeAssertionMessage:(e,t,r)=>`Expected ${e} to be of type ${t}, encountered: ${r}`}}}]);