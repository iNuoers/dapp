/*
 * https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType
 */
var NodeType;
(function (NodeType) {
    NodeType[NodeType["Tag"] = 1] = "Tag";
    NodeType[NodeType["Text"] = 3] = "Text";
    NodeType[NodeType["CDATA"] = 4] = "CDATA";
    NodeType[NodeType["XMLDecl"] = 7] = "XMLDecl";
    NodeType[NodeType["Comments"] = 8] = "Comments";
    NodeType[NodeType["Document"] = 9] = "Document";
    NodeType[NodeType["DocType"] = 10] = "DocType";
    NodeType[NodeType["DocumentFragment"] = 11] = "DocumentFragment";
})(NodeType || (NodeType = {}));

// 选择器混合字符，不含后代选择器（空格）
var selectorUnitCombinator;
(function (selectorUnitCombinator) {
    selectorUnitCombinator[selectorUnitCombinator[">"] = 1] = ">";
    selectorUnitCombinator[selectorUnitCombinator["+"] = 2] = "+";
    selectorUnitCombinator[selectorUnitCombinator["~"] = 3] = "~";
    selectorUnitCombinator[selectorUnitCombinator["&>"] = 4] = "&>";
})(selectorUnitCombinator || (selectorUnitCombinator = {}));
// 属性选择器等号修饰符
var attrModifier;
(function (attrModifier) {
    attrModifier[attrModifier["^"] = 1] = "^";
    attrModifier[attrModifier["$"] = 2] = "$";
    attrModifier[attrModifier["~"] = 3] = "~";
    attrModifier[attrModifier["|"] = 4] = "|";
    attrModifier[attrModifier["*"] = 5] = "*";
})(attrModifier || (attrModifier = {}));
// 用于验证的正则表达式
// css 选择器相关字符
const idChar = '#[^#\\.\\[\\*:\\s,]+';
const classChar = '\\.[^#\\.\\[\\*:\\s,]+';
const attrChar = '\\[[a-zA-Z][a-zA-Z0-9\\-]*(?:[\\|\\^\\$\\*~]?=(?:\'[^\']*\'|"[^"]*"|[^\'"\\]]+))?\\]';
const pseudoChar = '\\:{1,2}[a-zA-Z-]+(?:\\((?:[^\\(\\)]*|[^\\(\\)]*\\([^\\(\\)]*\\))\\))?';
// export const validPseudoClass = ['hover', 'link', 'active', 'visited', 'focus', 'first-child', 'lang', 'not', 'root'];
// 伪元素暂时只支持这几个
const validPseudoElement = ['first-letter', 'first-line', 'selection'];

// 解析 an+b of S
const parseNTH = (type) => {
    const [anb, ofS] = type.split(/\s+of\s+/).map(s => s.trim());
    let a = 0;
    let b = 0;
    if (anb === 'even') {
        a = 2;
    }
    else if (anb === 'odd') {
        a = 2;
        b = 1;
    }
    else {
        const nth = /^([+-]?\d*)n(?:\s*([+-])\s*(\d+))?$/i.exec(anb);
        if (nth) {
            if (/^[+-]?$/.test(nth[1])) { // 没有数字，则补1
                a = +`${nth[1]}1`;
            }
            else {
                a = +nth[1];
            }
            if (nth[2] && nth[3]) {
                b = (nth[2] === '+' ? 1 : -1) * (+nth[3]);
            }
        }
        else if (/^[+-]?\d+$/.test(anb)) {
            b = +anb;
        }
    }
    return [a, b, ofS !== null && ofS !== void 0 ? ofS : ''];
};
// 判断 an+b 格式的命中情况
const checkNTH = (node, list, a, b) => {
    const index = list.indexOf(node) + 1;
    // 当前元素被筛掉
    if (index === 0)
        return false;
    if (a <= 0) {
        if (b <= 0) {
            return false;
        }
        else {
            if (a === 0) {
                return b === index;
            }
            else {
                return index <= b && b % -a === index % -a;
            }
        }
    }
    else {
        b = b % a;
        if (b < 0) {
            b += a;
        }
        return index % a === b;
    }
};

const tagChar = '(?:[a-zA-Z]+|\\*)';
const selectorChar = `(?:${idChar}|${classChar}|${attrChar}|${pseudoChar})`;
const combinatorChar = '(?:\\s*[>+~]\\s*|\\s+)';
const selectorUnitReg = new RegExp(`^(${tagChar}?)(${selectorChar}*)(${combinatorChar}|$)`);
const selectorGroupReg = new RegExp(`^(\\s*>\\s*)?((?:${tagChar}${selectorChar}*|${tagChar}?${selectorChar}+)(?:${combinatorChar}(?:${tagChar}${selectorChar}*|${tagChar}?${selectorChar}+))*)\\s*(?:,|$)`);
const parseSelectorUnit = (selector) => {
    const selectors = [];
    let selectorStr = selector.trim();
    let selectorExec = selectorUnitReg.exec(selectorStr);
    while (selectorExec && selectorExec[0].length) {
        const selectorUnit = { id: [], class: [], attr: [], pseudo: [] };
        if (selectorExec[1]) {
            if (selectorExec[1] === '*') {
                selectorUnit.universal = true;
            }
            else {
                selectorUnit.type = selectorExec[1];
            }
        }
        if (selectorExec[2]) {
            let specialStr = selectorExec[2];
            const specialReg = new RegExp(`^${selectorChar}`);
            let specialExec = specialReg.exec(specialStr);
            while (specialExec) {
                switch (specialExec[0][0]) {
                    case '.': // class 选择器
                        selectorUnit.class.push(specialExec[0].slice(1));
                        break;
                    case '[': { // 属性选择器
                        const attrStr = specialExec[0].slice(1, -1);
                        const eqIndex = attrStr.indexOf('=');
                        if (eqIndex === -1) {
                            // 没有等号的情况
                            selectorUnit.attr.push({
                                key: attrStr,
                            });
                        }
                        else {
                            // 取出等号修饰符
                            if (typeof attrModifier[attrStr[eqIndex - 1]] === 'number') {
                                selectorUnit.attr.push({
                                    key: attrStr.slice(0, eqIndex - 1),
                                    modifier: attrModifier[attrStr[eqIndex - 1]],
                                    value: attrStr.slice(eqIndex + 1),
                                });
                            }
                            else {
                                selectorUnit.attr.push({
                                    key: attrStr.slice(0, eqIndex),
                                    value: attrStr.slice(eqIndex + 1),
                                });
                            }
                        }
                        break;
                    }
                    case ':': { // 伪类，伪元素
                        const isClass = specialExec[0][1] !== ':';
                        const pseudoStr = specialExec[0].replace(/^:+/, '').trim();
                        const parenIndex = pseudoStr.indexOf('(');
                        if (parenIndex === -1) {
                            // 不是函数型伪类
                            selectorUnit.pseudo.push({
                                func: pseudoStr,
                                isClass,
                            });
                        }
                        else {
                            selectorUnit.pseudo.push({
                                func: pseudoStr.slice(0, parenIndex).trim(),
                                value: pseudoStr.slice(parenIndex + 1, -1).trim(),
                                isClass,
                            });
                        }
                        break;
                    }
                    default: // id 选择器
                        selectorUnit.id.push(specialExec[0].slice(1));
                        break;
                }
                specialStr = specialStr.slice(specialExec[0].length);
                specialExec = specialReg.exec(specialStr);
            }
        }
        if (selectorExec[3]) {
            const combinator = selectorExec[3].trim();
            if (typeof selectorUnitCombinator[combinator] === 'number') {
                selectorUnit.combinator = selectorUnitCombinator[combinator];
            }
        }
        selectors.push(selectorUnit);
        selectorStr = selectorStr.slice(selectorExec[0].length).trim();
        selectorExec = selectorUnitReg.exec(selectorStr);
    }
    return selectors;
};
const parseSelector = (query) => {
    const groups = [];
    let queryStr = query.trim();
    let queryExec = selectorGroupReg.exec(queryStr);
    while (queryExec) {
        const selectors = parseSelectorUnit(queryExec[2]);
        // 选择器允许以 > 开始
        if (queryExec[1]) {
            selectors.unshift({
                combinator: selectorUnitCombinator['&>'],
                id: [],
                class: [],
                attr: [],
                pseudo: [],
            });
        }
        groups.push(selectors);
        queryStr = queryStr.slice(queryExec[0].length).trim();
        if (!queryStr) {
            return groups;
        }
        queryExec = selectorGroupReg.exec(queryStr);
    }
    return [];
};

// 验证 className
const checkClass = (node, selector) => {
    if (node.nodeType !== NodeType.Tag)
        return false;
    const classAttr = node.getAttribute('class');
    let classNames = [];
    if (classAttr) {
        classNames = classAttr.trim().split(/\s+/);
    }
    return selector.class.every(className => classNames.includes(className));
};
// 验证 ID
const checkID = (node, selector) => {
    if (node.nodeType !== NodeType.Tag)
        return false;
    let id = node.getAttribute('id');
    if (id) {
        id = id.trim();
    }
    return selector.id.every(_id => _id === id);
};
// 验证属性
const checkAttr = (node, selector) => {
    if (node.nodeType !== NodeType.Tag)
        return false;
    for (let ai = selector.attr.length; ai--;) {
        const attrSelector = selector.attr[ai];
        let attr = node.getAttribute(attrSelector.key);
        if (attr === null) {
            return false;
        }
        else if (attrSelector.value) {
            // 属性值大小写不敏感
            const value = attrSelector.value.trim().toLowerCase();
            attr = attr.trim().toLowerCase();
            switch (attrSelector.modifier) {
                // 开始字符匹配
                case attrModifier['^']:
                    if (attr.indexOf(value) !== 0) {
                        return false;
                    }
                    break;
                // 结尾字符匹配
                case attrModifier['$']:
                    if (attr.lastIndexOf(value) !== attr.length - value.length) {
                        return false;
                    }
                    break;
                // 空格分组字符匹配
                case attrModifier['~']:
                    if (!attr.split(/\s+/).includes(value)) {
                        return false;
                    }
                    break;
                // 前缀字符匹配
                case attrModifier['|']:
                    if (attr !== value && attr.indexOf(`${value}-`) !== 0) {
                        return false;
                    }
                    break;
                // 模糊匹配
                case attrModifier['*']:
                    if (!attr.includes(value)) {
                        return false;
                    }
                    break;
                // 默认全字匹配
                default:
                    if (attr !== value) {
                        return false;
                    }
                    break;
            }
        }
    }
    return true;
};
// 验证伪类和伪元素
// 部分伪类可以直接通过验证，部分伪类需要进一步验证，个别在特定列表里的伪元素需要符合条件才能通过验证
// 目前支持到 CSS-selectors-3 https://www.w3.org/TR/selectors-3/
const checkPseudo = (node, selector) => {
    if (node.nodeType !== NodeType.Tag)
        return false;
    for (let pi = selector.pseudo.length; pi--;) {
        const pseudoSelector = selector.pseudo[pi];
        // 只在命中特定的伪元素时，验证作用域链上是否存在文本节点 text
        if (validPseudoElement.includes(pseudoSelector.func)) {
            let hasText = false;
            if (node.nodeName === 'text') {
                hasText = true;
            }
            else {
                if (node.querySelector('text')) {
                    hasText = true;
                }
            }
            if (!hasText) {
                return false;
            }
        }
        else if (pseudoSelector.isClass) {
            switch (pseudoSelector.func) {
                case 'empty': // 自身没有子标签
                    return node.children.length === 0;
                case 'first-child': // 自身是父元素的第一个子标签
                    if (node.parentNode) {
                        return node.parentNode.children[0] === node;
                    }
                    return false;
                case 'last-child':
                    if (node.parentNode) {
                        const children = node.parentNode.children;
                        return children[children.length - 1] === node;
                    }
                    return false;
                case 'only-child': // 自身是父元素唯一的子标签
                    if (node.parentNode) {
                        return node.parentNode.children.length === 1;
                    }
                    return false;
                case 'nth-child': // 自身是父元素唯一的子标签
                    if (node.parentNode && pseudoSelector.value) {
                        const [a, b, ofS] = parseNTH(pseudoSelector.value);
                        let children = node.parentNode.children;
                        if (ofS) {
                            children = children.filter(c => c.matches(ofS));
                        }
                        return checkNTH(node, children, a, b);
                    }
                    return false;
                case 'nth-last-child': // 自身是父元素唯一的子标签
                    if (node.parentNode && pseudoSelector.value) {
                        const [a, b, ofS] = parseNTH(pseudoSelector.value);
                        let children = node.parentNode.children.reverse();
                        if (ofS) {
                            children = children.filter(c => c.matches(ofS));
                        }
                        return checkNTH(node, children, a, b);
                    }
                    return false;
                case 'first-of-type': // 自身是父元素第一个同类型子元素
                    if (node.parentNode) {
                        return node.parentNode.querySelectorAll(node.nodeName)[0] === node;
                    }
                    return false;
                case 'last-of-type': // 自身是父元素最后一个同类型子元素
                    if (node.parentNode) {
                        const typeChildren = node.parentNode.querySelectorAll(node.nodeName);
                        return typeChildren[typeChildren.length - 1] === node;
                    }
                    return false;
                case 'only-of-type': // 自身是父元素唯一的同类型子元素
                    if (node.parentNode) {
                        return node.parentNode.querySelectorAll(node.nodeName).length === 1;
                    }
                    return false;
                case 'nth-of-type': // 自身是父元素唯一的子标签
                    if (node.parentNode && pseudoSelector.value) {
                        const [a, b, ofS] = parseNTH(pseudoSelector.value);
                        let typeChildren = node.parentNode.querySelectorAll(node.nodeName);
                        if (ofS) {
                            typeChildren = typeChildren.filter(c => c.matches(ofS));
                        }
                        return checkNTH(node, typeChildren, a, b);
                    }
                    return false;
                case 'nth-last-of-type': // 自身是父元素唯一的子标签
                    if (node.parentNode && pseudoSelector.value) {
                        const [a, b, ofS] = parseNTH(pseudoSelector.value);
                        let typeChildren = node.parentNode.querySelectorAll(node.nodeName).reverse();
                        if (ofS) {
                            typeChildren = typeChildren.filter(c => c.matches(ofS));
                        }
                        return checkNTH(node, typeChildren, a, b);
                    }
                    return false;
                case 'target': // 只有具备 id 或 name 属性的元素才可能被命中
                    return node.hasAttribute('id') || node.hasAttribute('name');
                case 'not': // not 伪类需要反转规则，匹配不能命中 pseudoSelector.value 的元素，如果 pseudoSelector.value 解析失败，也返回 false
                    if (pseudoSelector.value) {
                        const selectors = parseSelector(pseudoSelector.value);
                        if (selectors.length) {
                            return !node.matches(selectors);
                        }
                    }
                    return false;
                case 'lang': // 语言，命中系统语言或 lang="" 属性，因为不能判断系统语言，因此直接返回 true
                case 'link': // CSS2 伪类，可命中任意元素
                case 'visited': // CSS2 伪类，可命中任意元素
                case 'hover': // CSS2 伪类，可命中任意元素
                case 'active': // CSS2 伪类，可命中任意元素
                case 'focus': // CSS2 伪类，可命中任意元素
                    return true;
                case 'root':
                    return !node.parentNode || node.parentNode.nodeType !== NodeType.Tag;
                default: // 其它伪类暂不进行验证，默认返回 false
                    return false;
            }
        }
        else {
            return false;
        }
    }
    return true;
};
// 验证 selector 和 node 是否匹配
const matchSelector = (selector, node) => {
    // 如果存在标签，则标签必须符合
    if (selector.type && selector.type !== node.nodeName) {
        return false;
    }
    // 如果存在 class 选择器，则每个 class 都要匹配
    if (selector.class.length) {
        if (!checkClass(node, selector)) {
            return false;
        }
    }
    // 如果存在 id 选择器，则每个 id 都要匹配
    if (selector.id.length) {
        if (!checkID(node, selector)) {
            return false;
        }
    }
    if (selector.attr.length) {
        if (!checkAttr(node, selector)) {
            return false;
        }
    }
    if (selector.pseudo.length) {
        if (!checkPseudo(node, selector)) {
            return false;
        }
    }
    return true;
};
const matchSelectors = (selectors, node, finder) => {
    const selectorsLength = selectors.length;
    if (!selectorsLength)
        return false;
    if (!matchSelector(selectors[selectorsLength - 1], node))
        return false;
    let currentNode = node;
    let currentSelectorIndex = selectorsLength - 2;
    while (currentSelectorIndex >= 0) {
        // 如果最顶层选择器中包含 :root，则跳过验证
        if (currentSelectorIndex === 0 && selectors[0].pseudo.findIndex(p => p.func === 'root') !== -1) {
            break;
        }
        switch (selectors[currentSelectorIndex].combinator) {
            // finder 的子元素
            case selectorUnitCombinator['&>']:
                if (currentNode.parentNode === finder) {
                    break;
                }
                return false;
            // 子选择器
            case selectorUnitCombinator['>']:
                if (currentNode.parentNode) {
                    if (!matchSelector(selectors[currentSelectorIndex], currentNode.parentNode)) {
                        return false;
                    }
                    currentNode = currentNode.parentNode;
                    break;
                }
                return false;
            // 相邻兄弟选择器
            case selectorUnitCombinator['+']:
                if (currentNode.parentNode) {
                    const brothers = currentNode.parentNode.childNodes;
                    let nodeIndex = brothers.indexOf(currentNode);
                    let brother;
                    while (nodeIndex > 0) {
                        if (brothers[nodeIndex - 1].nodeType === NodeType.Tag) {
                            brother = brothers[nodeIndex - 1];
                            break;
                        }
                        nodeIndex--;
                    }
                    if (!brother || !matchSelector(selectors[currentSelectorIndex], brother)) {
                        return false;
                    }
                    currentNode = brothers[nodeIndex - 1];
                    break;
                }
                return false;
            // 兄弟选择器
            case selectorUnitCombinator['~']:
                if (currentNode.parentNode) {
                    const _brothers = currentNode.parentNode.childNodes;
                    const index = _brothers.indexOf(currentNode);
                    if (index <= 0) {
                        return false;
                    }
                    let _brother;
                    for (let bi = index; bi--;) {
                        if (_brothers[bi].nodeType === NodeType.Tag) {
                            _brother = _brothers[bi];
                            if (matchSelector(selectors[currentSelectorIndex], _brother)) {
                                currentNode = _brother;
                                break;
                            }
                        }
                    }
                    if (currentNode !== _brother) {
                        return false;
                    }
                    break;
                }
                return false;
            // 后代选择器
            default: {
                let parent = currentNode.parentNode;
                while (parent) {
                    if (matchSelector(selectors[currentSelectorIndex], parent)) {
                        currentNode = parent;
                        break;
                    }
                    parent = parent.parentNode;
                }
                if (currentNode !== parent) {
                    return false;
                }
                break;
            }
        }
        currentSelectorIndex--;
    }
    return true;
};
const matchSelectorGroups = (selectorGroups, node, finder) => selectorGroups.some(selectors => matchSelectors(selectors, node, finder));

// 合并连续的空白
const mixWhiteSpace = (str) => str.replace(/\s+/g, ' ');

const stringifyNode = (node) => {
    let xml = '';
    const textContent = node.textContent || '';
    switch (node.nodeType) {
        case NodeType.Tag:
            xml += stringifyTag(node);
            break;
        case NodeType.Text:
            xml += mixWhiteSpace(textContent);
            break;
        case NodeType.XMLDecl:
            xml += `<?xml${mixWhiteSpace(` ${textContent}`).replace(/\s(?="|=|$)/g, '')}?>`;
            break;
        case NodeType.Comments: {
            const comments = mixWhiteSpace(textContent).trim();
            if (comments) {
                xml += `<!--${comments}-->`;
            }
            break;
        }
        case NodeType.CDATA:
            if (!textContent.includes('<')) {
                xml += mixWhiteSpace(textContent);
            }
            else {
                xml += `<![CDATA[${mixWhiteSpace(textContent)}]]>`;
            }
            break;
        case NodeType.DocType:
            xml += `<!DOCTYPE${mixWhiteSpace(` ${textContent.trim()}`)}>`;
            break;
        default:
            // document | documentFragment
            xml += stringifySVG(node);
            break;
    }
    return xml;
};
const stringifyTag = (node) => {
    let xml = '';
    xml += `<${node.namespace ? `${node.namespace}:` : ''}${node.nodeName}`;
    if (node.attributes.length) {
        for (const { name, value, namespace } of node.attributes) {
            const val = value.trim();
            if (val) {
                xml += ` ${namespace ? `${namespace}:` : ''}${name}="${mixWhiteSpace(val).replace(/"/g, '&quot;')}"`;
            }
        }
    }
    if (node.childNodes.length) {
        xml += '>';
        xml += stringifySVG(node);
        xml += `</${node.namespace ? `${node.namespace}:` : ''}${node.nodeName}>`;
    }
    else {
        xml += '/>';
    }
    return xml;
};
const stringifySVG = (dom) => {
    if (!dom)
        return '';
    return dom.childNodes.reduce((result, node) => `${result}${stringifyNode(node)}`, '');
};

class Node {
    constructor(option) {
        this.nodeName = option.nodeName;
        this.nodeType = option.nodeType;
        this.namespace = option.namespace;
    }
    /**
     * 移除当前节点
     */
    remove() {
        if (this.parentNode) {
            return this.parentNode.removeChild(this);
        }
        return false;
    }
    /**
     * 验证当前节点是否符合指定条件
     * @param selector 处理函数 / 节点类型 / css 选择器
     */
    matches(selector, finder) {
        // 传入处理函数的情况
        if (typeof selector === 'function') {
            return selector(this);
        }
        // 传入节点类型的情况
        if (typeof selector === 'number') {
            return this.nodeType === selector;
        }
        // 传入 css 选择器的情况
        const selectorGroups = typeof selector === 'string' ? parseSelector(selector) : selector;
        if (Array.isArray(selectorGroups)) {
            if (Array.isArray(selectorGroups[0])) {
                return matchSelectorGroups(selectorGroups, this, finder);
            }
            return matchSelectors(selectorGroups, this, finder);
        }
        return matchSelector(selectorGroups, this);
    }
    closest(selector) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let tag = this;
        const selectorGroups = typeof selector === 'string' ? parseSelector(selector) : selector;
        while (tag) {
            if (tag.matches(selectorGroups)) {
                return tag;
            }
            tag = tag.parentNode;
        }
        return null;
    }
    toString() {
        return stringifyNode(this);
    }
}

/*
 * 递归遍历所有的 Node 后代节点，并对符合条件的节点执行操作
 */
const traversal = (condition, node, breakImmediate, result) => {
    // 此处不能用 forEach ，for 循环可以避免当前节点被移除导致下一个节点不会被遍历到的问题
    if (node.nodeType === NodeType.Tag || node.nodeType === NodeType.Document) {
        for (let i = 0; i < node.childNodes.length; i++) {
            const childNode = node.childNodes[i];
            if (condition(childNode)) {
                result.push(childNode);
                if (breakImmediate) {
                    break;
                }
            }
            traversal(condition, childNode, breakImmediate, result);
            if (breakImmediate && result.length) {
                break;
            }
        }
    }
    return result;
};
/**
 * @param condition 判断条件
 * @param node 起始节点（起始节点不参与判断）
 * @param breakImmediate 设置为 true 表示找到第一个符合条件的元素即中断
 */
const getNodesByCondition = (condition, node, breakImmediate = false) => {
    return traversal(condition, node, breakImmediate, []);
};

/**
 * 将 documentFragment 的所有子节点插入到目标节点的准备工作
 * @param node 目标节点
 * @param fragment documentFragment
 */
const updateFragment = (node, fragment) => {
    const children = fragment.childNodes.map(child => {
        child.parentNode = node;
        return child;
    });
    fragment.childNodes.length = 0;
    return children;
};

class ParentNode extends Node {
    constructor(option) {
        super(option);
        this.nodeType = option.nodeType;
        this.childNodes = [];
    }
    get children() {
        const children = [];
        for (const child of this.childNodes) {
            if (child.nodeType === NodeType.Tag) {
                children.push(child);
            }
        }
        return children;
    }
    /**
     * 复制自身，但是不复制节点树关系链
     */
    cloneNode() {
        const cloneNode = new ParentNode({
            nodeName: this.nodeName,
            nodeType: this.nodeType,
            namespace: this.namespace,
        });
        // 属性需要深拷贝
        return cloneNode;
    }
    /**
     * 追加子节点
     * @param childNode 要追加的节点
     */
    appendChild(childNode) {
        if (Array.isArray(childNode)) {
            return [...childNode].reduce((prev, child) => this.appendChild(child) && prev, true);
        }
        // 自身/祖先元素不能被追加
        if (this.closest(node => node === childNode)) {
            return false;
        }
        // DocumentFragment 需要特殊处理
        if (childNode.nodeType === NodeType.DocumentFragment) {
            const children = updateFragment(this, childNode);
            this.childNodes.push(...children);
            return true;
        }
        // 如果子节点原本有父节点，则先从原本的父节点中移除
        if (childNode.parentNode) {
            childNode.parentNode.removeChild(childNode);
        }
        this.childNodes.push(childNode);
        childNode.parentNode = this;
        return true;
    }
    /**
     * 插入到子节点之前
     * @param childNode 要插入的节点
     * @param previousTarget 插入到哪个子字节之前
     */
    insertBefore(childNode, previousTarget) {
        if (Array.isArray(childNode)) {
            return [...childNode].reduce((prev, child) => this.insertBefore(child, previousTarget) && prev, true);
        }
        // 自身/祖先元素不能被追加
        if (this.closest(node => node === childNode)) {
            return false;
        }
        // DocumentFragment 需要特殊处理
        if (childNode.nodeType === NodeType.DocumentFragment) {
            const pIndex = this.childNodes.indexOf(previousTarget);
            const children = updateFragment(this, childNode);
            if (pIndex !== -1) {
                this.childNodes.splice(pIndex, 0, ...children);
            }
            else {
                this.childNodes.push(...children);
            }
            return true;
        }
        // 子元素自身插入到自身之前的问题
        if (childNode === previousTarget && childNode.parentNode === this) {
            return true;
        }
        // 如果子节点原本有父节点，则先从原本的父节点中移除
        childNode.remove();
        // pIndex 的获取要在 childNode 被移除之后，避免 childNode 就是当前节点的子节点，导致 pIndex 被意外更新
        const pIndex = this.childNodes.indexOf(previousTarget);
        // 判断目标节点是否在自己的子节点列表中，如果不在，直接插入
        if (pIndex !== -1) {
            this.childNodes.splice(pIndex, 0, childNode);
        }
        else {
            this.childNodes.push(childNode);
        }
        childNode.parentNode = this;
        return true;
    }
    /**
     * 替换子节点
     * @param newChild 新的子节点
     * @param oldChild 要替换的旧节点
     */
    replaceChild(newChild, oldChild) {
        let returnVal = null;
        if (Array.isArray(newChild)) {
            const children = new Set();
            // 用于标记是否存在自身替换自身的情况
            let replaceSize = 1;
            let oIndex = this.childNodes.indexOf(oldChild);
            [...newChild].forEach(child => {
                // 自身/祖先元素不能被追加
                if (this.closest(node => node === child)) {
                    return;
                }
                if (child.nodeType === NodeType.DocumentFragment) {
                    updateFragment(this, child).forEach(n => {
                        children.add(n);
                    });
                    return;
                }
                // 子元素自身替换自身的问题
                if (child.parentNode === this) {
                    const cIndex = this.childNodes.indexOf(child);
                    if (cIndex !== -1 && cIndex < oIndex) {
                        oIndex--;
                    }
                    else if (child === oldChild) {
                        replaceSize = 0;
                    }
                }
                child.remove();
                child.parentNode = this;
                children.add(child);
            });
            if (oIndex !== -1) {
                returnVal = replaceSize ? oldChild : null;
                this.childNodes.splice(oIndex, replaceSize, ...children);
                if (returnVal) {
                    // 清理旧节点的父节点指向
                    delete oldChild.parentNode;
                }
            }
            else {
                this.childNodes.push(...children);
            }
            return returnVal;
        }
        // 自身/祖先元素不能被追加
        if (this.closest(node => node === newChild)) {
            return returnVal;
        }
        // DocumentFragment 需要特殊处理
        if (newChild.nodeType === NodeType.DocumentFragment) {
            const oIndex = this.childNodes.indexOf(oldChild);
            const children = updateFragment(this, newChild);
            if (oIndex !== -1) {
                returnVal = oldChild;
                this.childNodes.splice(oIndex, 1, ...children);
                // 清理旧节点的父节点指向
                delete oldChild.parentNode;
            }
            else {
                this.childNodes.push(...children);
            }
            return returnVal;
        }
        // 子元素自身替换自身的问题
        if (newChild === oldChild && newChild.parentNode === this) {
            return null;
        }
        // 先把要插入的子节点从原有父节点移除
        newChild.remove();
        // 指定父节点到自身
        newChild.parentNode = this;
        // oIndex 的获取要在 newChild 被移除之后，避免 newChild 就是当前节点的子节点，导致 oIndex 被意外更新
        const oIndex = this.childNodes.indexOf(oldChild);
        if (oIndex !== -1) {
            returnVal = oldChild;
            // 替换旧节点
            this.childNodes[oIndex] = newChild;
            // 清理旧节点的父节点指向
            delete oldChild.parentNode;
        }
        else {
            this.childNodes.push(newChild);
        }
        return returnVal;
    }
    /**
     * 移除子节点
     * @param childNode 要移除的子节点
     */
    removeChild(childNode) {
        if (Array.isArray(childNode)) {
            return [...childNode].reduce((prev, child) => this.removeChild(child) && prev, true);
        }
        const index = this.childNodes.indexOf(childNode);
        if (index !== -1) {
            this.childNodes.splice(index, 1);
            delete childNode.parentNode;
            return true;
        }
        return false;
    }
    querySelector(selector) {
        var _a;
        const selectorGroups = typeof selector === 'string' ? parseSelector(selector) : selector;
        return (_a = getNodesByCondition(node => node.matches(selectorGroups, this), this, true)[0]) !== null && _a !== void 0 ? _a : null;
    }
    querySelectorAll(selector) {
        const selectorGroups = typeof selector === 'string' ? parseSelector(selector) : selector;
        return getNodesByCondition(node => node.matches(selectorGroups, this), this);
    }
}

class TagNode extends ParentNode {
    constructor(option) {
        super(option);
        this.nodeType = NodeType.Tag;
        this.attributes = [];
    }
    /**
     * 复制自身，但是不复制节点树关系链
     */
    cloneNode() {
        const cloneNode = new TagNode({
            nodeName: this.nodeName,
            nodeType: this.nodeType,
            namespace: this.namespace,
        });
        // 属性需要深拷贝
        cloneNode.attributes = this.attributes.map(attr => ({ ...attr }));
        return cloneNode;
    }
    /**
     * 是否存在属性
     * @param _name 属性名
     * @param _namespace 属性命名空间
     */
    hasAttribute(_name, _namespace) {
        for (const { fullname, name, namespace } of this.attributes) {
            if (!_namespace) {
                if (fullname === _name) {
                    return true;
                }
            }
            else {
                if (name === _name && namespace === _namespace) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * 获取属性
     * @param _name 属性名
     * @param _namespace 属性命名空间
     */
    getAttribute(_name, _namespace) {
        for (const { name, value, fullname, namespace } of this.attributes) {
            if (!_namespace) {
                if (fullname === _name) {
                    return value;
                }
            }
            else {
                if (name === _name && namespace === _namespace) {
                    return value;
                }
            }
        }
        return null;
    }
    /**
     * 设置属性
     * @param name 属性名
     * @param value 属性值
     * @param namespace 属性命名空间
     */
    setAttribute(name, value, namespace) {
        for (const attr of this.attributes) {
            if (!namespace) {
                if (attr.fullname === name) {
                    attr.value = value;
                    return;
                }
            }
            else {
                if (attr.name === name && attr.namespace === namespace) {
                    attr.value = value;
                    return;
                }
            }
        }
        const newAttr = {
            name,
            value,
            fullname: name,
        };
        if (namespace) {
            newAttr.fullname = `${namespace}:${name}`;
            newAttr.namespace = namespace;
        }
        this.attributes.push(newAttr);
    }
    /**
     * 移除属性
     * @param _name 属性名
     * @param _namespace 属性命名空间
     */
    removeAttribute(_name, _namespace) {
        for (let i = this.attributes.length; i--;) {
            const { fullname, name, namespace } = this.attributes[i];
            if (!_namespace) {
                if (fullname === _name) {
                    this.attributes.splice(i, 1);
                    return true;
                }
            }
            else {
                if (name === _name && namespace === _namespace) {
                    this.attributes.splice(i, 1);
                    return true;
                }
            }
        }
        return false;
    }
}

class TextNode extends Node {
    constructor(option) {
        super(option);
        this.nodeType = option.nodeType;
        this.textContent = option.textContent;
    }
    cloneNode() {
        const cloneNode = new TextNode({
            nodeName: this.nodeName,
            nodeType: this.nodeType,
            namespace: this.namespace,
            textContent: this.textContent,
        });
        return cloneNode;
    }
}

// 移除截取字符串两端的引号
const collapseQuots = (str) => str.slice(1, -1);

let supportUnicode = true;
try {
    supportUnicode = /\u{20BB7}/u.test('𠮷');
}
catch (e) {
    supportUnicode = false;
}
const NameStartChar = `:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD${supportUnicode ? '\\u{10000}-\\u{EFFFF}' : ''}`;
const NameChar = `${NameStartChar}\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040`;
const Name = `[${NameStartChar}][${NameChar}]*`;
const Eq = '\\s*=\\s*';
const VersionNum = '1\\.[0-9]+';
const EncName = '[A-Za-z](?:[A-Za-z0-9\\._]|-)*';
const VersionInfo = `\\s+version${Eq}(?:'${VersionNum}'|"${VersionNum}")`;
const EncodingDecl = `\\s+encoding${Eq}(?:'${EncName}'|"${EncName}")`;
const SDDecl = `\\s+standalone${Eq}(?:'(?:yes|no)'|"(?:yes|no)")`;
const Reference = `(?:&${Name};|&#[0-9]+;|&#x[0-9a-fA-F]+;)`;
const AttrVal = `"(?:[^<&"]|${Reference})*"|'(?:[^<&']|${Reference})*'`;
const DeclContent = '(?:[^<>\'"]+|[^<>\']*\'[^\']*\'[^<>\']*|[^<>"]*"[^"]*"[^<>"]*|[^<>\'"]*<[^<>]*>[^<>\'"]*)+?';
const REG_XML_DECL = new RegExp(`<\\?xml(${VersionInfo}(?:${EncodingDecl})?(?:${SDDecl})?\\s*)\\?>`, 'g');
const REG_CDATA_SECT = /<!\[CDATA\[([\d\D]*?)\]\]>/g;
const REG_DOCTYPE = new RegExp(`<!DOCTYPE\\s+(${DeclContent})>`, 'g');
const REG_COMMENTS = /<!--([\d\D]*?)-->/g;
const REG_START_TAG = new RegExp(`<(${Name})((?:\\s+${Name}${Eq}(?:${AttrVal}))*)\\s*(\\/?)>`, supportUnicode ? 'gu' : 'g');
const REG_END_TAG = new RegExp(`</(${Name})\\s*>`, supportUnicode ? 'gu' : 'g');
const REG_ATTR = new RegExp(`(?:^|\\s)(${Name})${Eq}(${AttrVal})`, supportUnicode ? 'gu' : 'g');

const configs = [
    ['xml-decl', REG_XML_DECL, NodeType.XMLDecl],
    ['cdata', REG_CDATA_SECT, NodeType.CDATA],
    ['doctype', REG_DOCTYPE, NodeType.DocType],
    ['comments', REG_COMMENTS, NodeType.Comments],
];
const updStatus = (pos, str, status) => {
    for (; status.lastpos < pos; status.lastpos++) {
        if (str[status.lastpos] === '\r' || str[status.lastpos] === '\n') {
            // 换行判断，\r 直接换行，\n 判断一下是不是紧跟在 \r 后面
            if (str[status.lastpos] === '\r' || str[status.lastpos - 1] !== '\r') {
                status.line++;
                status.pos = 0;
            }
        }
        else {
            status.pos++;
        }
    }
};
const ProcessTagLess = ([name, reg, type], str, lastIndex) => {
    reg.lastIndex = lastIndex;
    const execResult = reg.exec(str);
    if (execResult && execResult.index === lastIndex) {
        return {
            node: new TextNode({
                nodeType: type,
                nodeName: `#${name}`,
                textContent: execResult[1],
            }),
            lastIndex: reg.lastIndex,
        };
    }
    return null;
};
// 处理标签
const ProcessTag = (str, status, lastIndex) => {
    REG_START_TAG.lastIndex = lastIndex;
    const execResult = REG_START_TAG.exec(str);
    if (execResult && execResult.index === lastIndex) {
        const tempStatus = { line: status.line, pos: status.pos, lastpos: 0 };
        const result = {
            node: new TagNode({
                nodeType: NodeType.Tag,
                nodeName: execResult[1],
                namespace: '',
            }),
            selfClose: execResult[3] === '/',
            lastIndex: REG_START_TAG.lastIndex,
        };
        // 标签的 namespace
        if (execResult[1].includes(':')) {
            const tagName = execResult[1].split(':');
            if (tagName.length !== 2 || !tagName[0] || !tagName[1]) {
                throw new Error(`Wrong start tag! At ${status.line}:${status.pos}`);
            }
            else {
                result.node.nodeName = tagName[1];
                result.node.namespace = tagName[0];
            }
        }
        updStatus(execResult[1].length + 1, execResult[0], tempStatus);
        // ** 重要 ** 重置匹配位置！
        REG_ATTR.lastIndex = 0;
        let attrExec = REG_ATTR.exec(execResult[2]);
        const attrUnique = {};
        while (attrExec) {
            updStatus(attrExec.index + execResult[1].length + 1, execResult[0], tempStatus);
            // 属性名排重
            if (attrUnique[attrExec[1]]) {
                throw new Error(`Duplicate property names! At ${tempStatus.line}:${tempStatus.pos}`);
            }
            attrUnique[attrExec[1]] = true;
            if (attrExec[1].includes(':')) {
                const attrName = attrExec[1].split(':');
                if (attrName.length === 2 && attrName[0] && attrName[1]) {
                    result.node.setAttribute(attrName[1], collapseQuots(attrExec[2]).trim(), attrName[0]);
                }
                else {
                    throw new Error(`Wrong attribute name! At ${tempStatus.line + status.line - 1}:${tempStatus.line > 1 ? tempStatus.pos : status.pos + tempStatus.pos}`);
                }
            }
            else {
                result.node.setAttribute(attrExec[1], collapseQuots(attrExec[2]).trim());
            }
            attrExec = REG_ATTR.exec(execResult[2]);
        }
        return result;
    }
    return null;
};
const ProcessEndTag = (str, status, lastIndex) => {
    REG_END_TAG.lastIndex = lastIndex;
    const execResult = REG_END_TAG.exec(str);
    if (execResult && execResult.index === lastIndex) {
        const result = {
            node: {
                nodeType: -1,
                nodeName: execResult[1],
                namespace: '',
            },
            lastIndex: REG_END_TAG.lastIndex,
        };
        if (execResult[1].includes(':')) {
            const tagName = execResult[1].split(':');
            if (tagName.length !== 2 || !tagName[1] || !tagName[0]) {
                throw new Error(`Wrong end tag! At ${status.line}:${status.pos}`);
            }
            else {
                result.node.nodeName = tagName[1];
                result.node.namespace = tagName[0];
            }
        }
        return result;
    }
    return null;
};
const parseNode = (str, status, lastIndex) => {
    const REG_LT = /</g;
    REG_LT.lastIndex = lastIndex;
    const ltExec = REG_LT.exec(str);
    if (ltExec) {
        if (ltExec.index === lastIndex) { // 以 < 开始的情况都按节点处理
            for (const cfg of configs) {
                const processTagLess = ProcessTagLess(cfg, str, lastIndex);
                if (processTagLess) {
                    return processTagLess;
                }
            }
            const processTag = ProcessTag(str, status, lastIndex);
            if (processTag) {
                return processTag;
            }
            const processEndTag = ProcessEndTag(str, status, lastIndex);
            if (processEndTag) {
                return processEndTag;
            }
            throw new Error(`Failed to parse nodes! At ${status.line}:${status.pos}`);
        }
        else { // 非 < 开始的都按文本处理
            return {
                node: new TextNode({
                    nodeType: NodeType.Text,
                    nodeName: '#text',
                    textContent: mixWhiteSpace(str.slice(lastIndex, ltExec.index)),
                }),
                lastIndex: ltExec.index,
            };
        }
    }
    else {
        return {
            node: new TextNode({
                nodeType: NodeType.Text,
                nodeName: '#text',
                textContent: mixWhiteSpace(str.slice(lastIndex)),
            }),
            lastIndex: str.length,
        };
    }
};
const parse = async (str) => {
    return new Promise((resolve, reject) => {
        const doc = new ParentNode({
            nodeType: NodeType.Document,
            nodeName: '#document',
        });
        const stack = [];
        const status = {
            line: 1,
            pos: 0,
            lastpos: 0,
        };
        const len = str.length;
        let current;
        let hasRoot = false;
        const firstIndex = str.indexOf('<');
        if (firstIndex > 0 && !/^\s+</.test(str)) {
            reject(new Error(`Unexpected text node! At ${status.line}:${status.pos}`));
            return;
        }
        try {
            current = parseNode(str, status, firstIndex); // 第一个 < 之前的全部字符都忽略掉
        }
        catch (e) {
            reject(e);
            return;
        }
        if (current.node.nodeType === NodeType.XMLDecl && firstIndex > 0) {
            reject(new Error(`The xml declaration must be at the front of the document! At ${status.line}:${status.pos}`));
            return;
        }
        if (current.node.nodeType === -1) {
            reject(new Error(`The start and end tags cannot match! At ${status.line}:${status.pos}`));
        }
        if (current.node.nodeType === NodeType.CDATA) {
            reject(new Error(`Invalid CDATA element! At ${status.line}:${status.pos}`));
        }
        doc.appendChild(current.node);
        if (current.node.nodeType === NodeType.Tag) {
            hasRoot = true;
            if (!current.selfClose) {
                stack.push(current.node);
            }
        }
        while (current.lastIndex < len) {
            updStatus(current.lastIndex, str, status);
            try {
                current = parseNode(str, status, current.lastIndex); // 第一个 < 之前的全部字符都忽略掉
            }
            catch (e) {
                reject(e);
                return;
            }
            const stackLen = stack.length;
            if (current.node.nodeType === -1) {
                // 遇到结束标签的处理逻辑
                if (stackLen) {
                    // 结束标签和开始标签匹配
                    if (stack[stackLen - 1].nodeName === current.node.nodeName && stack[stackLen - 1].namespace === current.node.namespace) {
                        stack.pop();
                    }
                    else {
                        reject(new Error(`The start and end tags cannot match! At ${status.line}:${status.pos}`));
                        return;
                    }
                }
                else {
                    // 没有开始标签而出现了结束标签
                    reject(new Error(`Unexpected end tag! At ${status.line}:${status.pos}`));
                    return;
                }
            }
            else {
                if (stackLen) {
                    // 插入子节点
                    stack[stackLen - 1].appendChild(current.node);
                }
                else if (current.node.nodeType === NodeType.CDATA) {
                    // CDATA 节点禁止出现在根下
                    reject(new Error(`Invalid CDATA element! At ${status.line}:${status.pos}`));
                    return;
                }
                else if (current.node.nodeType === NodeType.Text) {
                    // 没有节点而出现了非空文本节点
                    if (current.node.textContent.trim()) {
                        reject(new Error(`Unexpected text node! At ${status.line}:${status.pos}`));
                        return;
                    }
                }
                else {
                    // 直接扔到根下
                    doc.appendChild(current.node);
                }
                // 遇到未闭合的节点，扔到stack内
                if (current.node.nodeType === NodeType.Tag) {
                    if (!stackLen) {
                        if (hasRoot) {
                            reject(new Error(`Only one root element node is allowed! At ${status.line}:${status.pos}`));
                            return;
                        }
                        hasRoot = true;
                    }
                    if (!current.selfClose) {
                        stack.push(current.node);
                    }
                }
            }
            if (current.lastIndex === len) {
                updStatus(len, str, status);
            }
        }
        if (stack.length) {
            reject(new Error(`Document structure is wrong! At ${status.line}:${status.pos}`));
            return;
        }
        if (!hasRoot) {
            reject(new Error(`No root element node! At ${status.line}:${status.pos}`));
            return;
        }
        resolve(doc);
    });
};

export { NodeType, ParentNode, TagNode, TextNode, attrModifier, matchSelector, matchSelectorGroups, matchSelectors, parse, parseSelector, selectorUnitCombinator, stringifyNode, stringifySVG, stringifyTag };
