"use strict"
import {// eslint-disable-next-line import/named
  cancelAnimationFrameHandle,
  requestAnimationFrameHandle
} from "../../util/framehandle"

let ctx
let X
let Y

const dist = 200
const diffX = dist / 2
const diffY = dist / 1.5
let rendering_id
let shapeXNum = X / dist
let shapeYNum = Y / dist
let shapes = []
const ease = 0.3
const friction = 0.9
const style = {
  black: "black",
  white: "white",
  lineWidth: 3
}

/********************
 Shape
 ********************/
class Shape {
  constructor(ctx, x, y, i, j) {
    this.ctx = ctx
    this.init(x, y, i, j)
  }

  init(x, y, i, j) {
    this.x = x
    this.y = y
    this.i = i
    this.xi = rand(0, X)
    this.yi = rand(0, Y)
    this.r = dist / 2
    this.v = {
      x: 0,
      y: 0
    }
    this.a = this.i
    this.rad = this.a * Math.PI / 180
  }

  draw() {
    const ctx = this.ctx
    ctx.save()
    ctx.lineWidth = style.lineWidth
    ctx.fillStyle = style.black
    ctx.translate(this.xi, this.yi)
    ctx.rotate(this.rad)
    ctx.translate(-this.xi, -this.yi)
    for (let i = 0; i < 3; i++) {
      if (i === 1) {
        ctx.fillStyle = style.white
      } else {
        ctx.fillStyle = style.black
      }
      ctx.beginPath()
      ctx.arc(this.xi, this.yi, this.r - 20 * i, 0, Math.PI * 2, false)
      ctx.fill()
    }
    ctx.strokeStyle = style.white
    ctx.fillStyle = style.white
    for (let i = 0; i < 12; i++) {
      ctx.translate(this.xi, this.yi)
      ctx.rotate(30 * Math.PI / 180)
      ctx.translate(-this.xi, -this.yi)
      ctx.beginPath()
      ctx.moveTo(this.xi, this.yi)
      ctx.lineTo(this.xi, this.yi + this.r / 2.5)
      ctx.stroke()
      ctx.beginPath()
      ctx.arc(this.xi, this.yi + this.r / 2.5, this.r / 20, 0, Math.PI * 2, false)
      ctx.fill()
    }
    ctx.restore()
  }

  updatePosition() {
    this.v.x += (this.xi - this.x) * ease
    this.v.y += (this.yi - this.y) * ease
    this.v.x *= friction
    this.v.y *= friction
    this.xi -= this.v.x / 100
    this.yi -= this.v.y / 100
  }

  updateParams() {
    if (this.i % 2 === 0) {
      this.a += 0.3
    } else {
      this.a -= 0.3
    }
    this.rad = this.a * Math.PI / 180
  }

  render() {
    this.updateParams()
    this.updatePosition()
    this.draw()
  }
}

/********************
 Render
 ********************/

function render() {
  ctx.clearRect(0, 0, X, Y)
  for (let i = 0; i < shapes.length; i++) {
    shapes[i].render(i)
  }
  rendering_id = requestAnimationFrameHandle(render)
}

function Clear() {
  ctx.clearRect(0, 0, X, Y)
  cancelAnimationFrameHandle(rendering_id)
}

/********************
 Random Number
 ********************/

function rand(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min)
}

/********************
 Event
 ********************/

function regen() {
  shapes = []
  for (let i = 0; i < shapeYNum * 2 * 1.5 + 1; i++) {
    for (let j = 0; j < shapeXNum + 1; j++) {
      let s
      if (i % 2 === 0) {
        s = new Shape(ctx, j * dist + diffX, i * dist - diffY * i, j)
      } else {
        s = new Shape(ctx, j * dist, i * dist - diffY * i, j)
      }
      shapes.push(s)
    }
  }
}

function StartBackgroundAnim(elementID) {
  const canvas = document.getElementById(elementID)
  if (!canvas || !canvas.getContext) {
    return false
  }

  ctx = canvas.getContext("2d")
  X = canvas.width = window.innerWidth
  Y = canvas.height = window.innerHeight

  shapeXNum = X / dist
  shapeYNum = Y / dist

  regen()
  render()

  function onResize() {
    X = canvas.width = window.innerWidth
    Y = canvas.height = window.innerHeight
    shapeXNum = X / dist
    shapeYNum = Y / dist
    regen()
  }

  window.addEventListener("resize", function () {
    onResize()
  })
}

export {
  StartBackgroundAnim,
  Clear
}
