/*
* File Name / no name
* Created Date / Oct 7, 2020
* Aurhor / Toshiya Marukubo
* Twitter / https://twitter.com/toshiyamarukubo
*/

"use strict"

// random number.
import { randIn } from "../three/wrapengine/mathlib"

function randomNumber(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min)
}

// random color rgb.
function randomColorRGB() {
  return (
    "rgb(" +
        randomNumber(0, 255) +
        ", " +
        randomNumber(0, 255) +
        ", " +
        randomNumber(0, 255) +
        ")"
  )
}

// random color hsl.
function randomColorHSL(saturation, lightness) {
  return (
    "hsl(" +
        randomNumber(0, 360) +
        ", " +
        saturation +
        "%, " +
        lightness +
        "%)"
  )
}

// gradient color.
function gradientColor(ctx, cr, cg, cb, ca, x, y, r) {
  const col = cr + "," + cg + "," + cb
  const g = ctx.createRadialGradient(x, y, 0, x, y, r)
  g.addColorStop(0, "rgba(" + col + ", " + (ca * 1) + ")")
  g.addColorStop(0.5, "rgba(" + col + ", " + (ca * 0.5) + ")")
  g.addColorStop(1, "rgba(" + col + ", " + (ca * 0) + ")")
  return g
}

function handleErrors(options) {
  const { inputFormat, stops, colorArray } = options

  if (typeof inputFormat !== "string") {
    // eslint-disable-next-line no-throw-literal
    throw "inputFormat should be a string"
  }

  const supportedFormats = ["hex", "rgb", "hsl"]
  const isValidFormat = supportedFormats.includes(inputFormat.toLowerCase())
  if (!isValidFormat) {
    // eslint-disable-next-line no-throw-literal
    throw "Invalid inputFormat value, supported: hex, rgb and hsl"
  }

  if (!Number.isInteger(stops)) {
    // eslint-disable-next-line no-throw-literal
    throw "stops should be an integer"
  }

  if (
    !Array.isArray(colorArray) ||
        !colorArray.every(item => typeof item === "string")
  ) {
    // eslint-disable-next-line no-throw-literal
    throw "colorArray should be an array of color strings"
  }

  if (stops < colorArray.length) {
    // eslint-disable-next-line no-throw-literal
    throw "Number of stops cannot be less than colorArray.length"
  }
}

function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
  const [, r, g, b] = result.map(function (val) {
    return parseInt(val, 16)
  })
  return result ? { r, g, b } : null
}

// if hex and defined as #fff then convert it to standard 7 letter format #ffffff
function standardizeHexValues(arrayOfHexStrings) {
  return arrayOfHexStrings.map((str) => {
    if (str.length === 4) {
      return `#${str[1] + str[1] + str[2] + str[2] + str[3] + str[3]}`
    } else if (str.length === 7) {
      return str
    }
  })
}

function extractHEX(arrayOfHexStrings) {
  return standardizeHexValues(arrayOfHexStrings).map(str => hexToRgb(str))
}

function extractRGB(arrayOfRGBStrings) {
  return arrayOfRGBStrings.map((str) => {
    const [r, g, b] = str.match(/\d+/g)
    return { r: Number(r), g: Number(g), b: Number(b) }
  })
}

function extractHSL(arrayOfHSLStrings) {
  return arrayOfHSLStrings.map((str) => {
    const [h, s, l] = str.match(/\d+/g)
    return { h: Number(h), s: Number(s), l: Number(l) }
  })
}

function getRGBString({ r, g, b }) {
  return `rgb(${r}, ${g}, ${b})`
}

function getHSLString({ h, s, l }) {
  return `hsl(${h}, ${s}%, ${l}%)`
}

// get r,g,b,h,s and l with Bezier interpolation
// https://www.cl.cam.ac.uk/teaching/2000/AGraphHCI/SMEG/node3.html
// Check issue #3 for more info
const bezierInterpolation = colorTypeChars => (colArr, x) => {
  const y = 1 - x
  let v
  return colorTypeChars.reduce((colorObject, char) => {
    if (colArr.length === 2) {
      v = y * colArr[0][char] + x * colArr[1][char]
    } else if (colArr.length === 3) {
      v =
                y ** 2 * colArr[0][char] +
                2 * y * x * colArr[1][char] +
                x ** 2 * colArr[2][char]
    } else if (colArr.length === 4) {
      v =
                y ** 3 * colArr[0][char] +
                3 * y ** 2 * x * colArr[1][char] +
                3 * y * x ** 2 * colArr[2][char] +
                x ** 3 * colArr[3][char]
    }
    colorObject[char] = Math.trunc(v)
    return colorObject
  }, {})
}

const rgbBezierInterpolation = bezierInterpolation(["r", "g", "b"])
const hslBezierInterpolation = bezierInterpolation(["h", "s", "l"])

const transformColorStringsToObjects = (options) => {
  switch (options.inputFormat) {
    case "hex":
      return extractHEX(options.colorArray)
    case "rgb":
      return extractRGB(options.colorArray)
    case "hsl":
      return extractHSL(options.colorArray)
  }
}

function stopsGenerator(options) {
  const outputArray = []
  const increment = 1.0 / (options.stops - 1)

  for (let i = 0; i < options.stops; i++) {
    if (options.inputFormat === "hex" || options.inputFormat === "rgb") {
      const rgbObject = rgbBezierInterpolation(options.colorArray, increment * i)
      outputArray.push(getRGBString(rgbObject))
    } else if (options.inputFormat === "hsl") {
      const hslObject = hslBezierInterpolation(options.colorArray, increment * i)
      outputArray.push(getHSLString(hslObject))
    }
  }

  return outputArray
}

function getStops(options) {
  const colorArray = transformColorStringsToObjects(options)
  // const optionsWithFormattedColorsValues = {...options, colorArray};
  const optionsWithFormattedColorsValues = Object.assign(colorArray, options)
  return stopsGenerator(optionsWithFormattedColorsValues)
}

class ColorTool {
  constructor(r, g, b, name) {
    this.r = r
    this.g = g
    this.b = b
    this.name = name
    this.calcHSL()
  }

  innerRGB() {
    const { r, g, b } = this
    return `${r}, ${g}, ${b}`
  }

  rgb() {
    return `rgb(${this.innerRGB()})`
  }

  rgba(a = 1.0) {
    return `rgba(${this.innerRGB()}, ${a})`
  }

  hex() {
    const { r, g, b } = this
    return (
      "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)
    )
  }

  hsl() {
    const { h, s, l } = this
    return `hsl(${h},${s}%, ${l}%)`
  }

  fulllySaturated() {
    const { h, l } = this
    return `hsl(${h},100%, ${l}%)`
  }

  data() {
    const { h, s, l } = this
    const { r, g, b } = this
    return {
      r,
      g,
      b,
      h,
      s,
      l
    }
  }

  opposite() {
    const { h, s, l } = this
    const newHue = (h + 180) % 360
    return `hsl(${newHue},${s}%, ${l}%)`
  }

  dim() {
    const { h, s, l } = this
    const newl = (l - 5) % 100
    return `hsl(${h},${s}%, ${newl}%)`
  }

  dimr(range) {
    const rk = randIn(0, range)
    const { h, s, l } = this
    const newl = (l - rk) % 100
    return `hsl(${h},${s}%, ${newl}%)`
  }

  calcHSL() {
    let { r, g, b } = this
    // Make r, g, and b fractions of 1
    r /= 255
    g /= 255
    b /= 255

    // Find greatest and smallest channel values
    const cmin = Math.min(r, g, b)
    const cmax = Math.max(r, g, b)
    const delta = cmax - cmin
    let h = 0
    let s = 0
    let l = 0
    if (delta === 0) {
      h = 0
    } else if (cmax === r) {
      // Red is max
      h = ((g - b) / delta) % 6
    } else if (cmax === g) {
      // Green is max
      h = (b - r) / delta + 2
    } else {
      // Blue is max
      h = (r - g) / delta + 4
    }

    h = Math.round(h * 60)

    // Make negative hues positive behind 360Â°
    if (h < 0) {
      h += 360
    }
    // Calculate lightness
    l = (cmax + cmin) / 2

    // Calculate saturation
    s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1))

    // Multiply l and s by 100
    s = +(s * 100).toFixed(1)
    l = +(l * 100).toFixed(1)
    this.h = h
    this.s = s
    this.l = l
  }
}
// Seedable random number generator.
// Not particularly well-distributed, but fine for this case.
// Allows us to emit the same set of random numbers on every frame
// so we can consistently re-render the scene.
const RNG = {
  seed: 1,
  random() {
    const x = Math.sin(RNG.seed++) * 10000
    return x - (x << 0)
  },
  randomInRange(min, max) {
    return ((RNG.random() * (max - min + 1)) << 0) + min
  }
}
// Module to get a random colour from a predefined list.
// Uses the seedable RNG
class ColorPalette {
  constructor(pal) {
    this.PAL = pal
    this.lastIndex = pal.length - 1
  }

  static setSeed(n) {
    RNG.seed = n
  }

  static randomRange(a, b) {
    return RNG.randomInRange(a, b)
  }

  static getRandomRNG() {
    return RNG.random()
  }

  getRandomFromPalette() {
    return this.PAL[RNG.randomInRange(0, this.lastIndex)]
  }
}

export {
  randomColorRGB,
  randomColorHSL,
  randomNumber,
  gradientColor,
  handleErrors,
  getStops,
  stopsGenerator,
  standardizeHexValues,
  getRGBString,
  extractHSL,
  hexToRgb,
  getHSLString,
  ColorTool,
  ColorPalette
}
